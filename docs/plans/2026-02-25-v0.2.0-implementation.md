# algebraic.dist v0.2.0 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add 7 distribution types, extend the algebra with new operators and simplification rules, add realize() as the universal escape hatch, and harden the entire package for CRAN resubmission.

**Architecture:** All new distributions follow the existing S3 pattern (constructor returns structure with class vector). New operators create edist objects and call simplify(). The realize() generic materializes any dist to empirical_dist by sampling. No breaking changes.

**Tech Stack:** R, S3 OOP, R6 (support classes), testthat edition 3, stats package for d/p/q/r functions.

**Conventions reference:** Use R/exponential.R as the template for new distribution files. Use tests/testthat/test-exponential.R as the template for new test files. Every constructor gets informative stop() calls. Every distribution implements: constructor, is_*, mean, vcov, params, nparams, dim, print, format, sup, sampler, density, cdf, inv_cdf. Reliability-relevant types also get hazard/surv.

**Design doc:** docs/plans/2026-02-25-v0.2.0-design.md

---

## Task 1: realize() generic and edist auto-fallback

The foundation everything else builds on. Must land first.

**Files:**
- Create: `R/realize.R`
- Modify: `R/edist.R` (add cdf.edist, density.edist, sup.edist, conditional.edist, rmap.edist, inv_cdf.edist)
- Create: `tests/testthat/test-realize.R`

Tests: realize.dist, realize.edist, realize.empirical_dist (returns self), default n=10000, n=0 errors, edist auto-fallback for cdf/density/conditional/rmap/sup/inv_cdf.

Implementation: realize() generic dispatching to realize.dist (sample + wrap in empirical_dist), realize.empirical_dist (return self). Edist fallback methods delegate through realize.

Commit: `feat: add realize() generic and edist auto-fallback methods`

---

## Task 2: gamma_dist distribution

**Files:**
- Create: `R/gamma_dist.R`
- Create: `tests/testthat/test-gamma_dist.R`

Constructor: gamma_dist(shape, rate), both positive scalars.
Classes: c("gamma_dist", "univariate_dist", "continuous_dist", "dist")
Mean: shape/rate, Var: shape/rate^2
Methods: full set + hazard (f/S ratio) + surv
Backed by: stats::dgamma, pgamma, qgamma, rgamma
Support: interval (0, Inf) open at 0

Tests: construction, validation, class hierarchy, is_gamma_dist, all accessors, sampler (statistical), density vs dgamma, cdf vs pgamma, inv_cdf round-trip, hazard = f/S, surv = 1-F, support, format, print.

Commit: `feat: add gamma_dist distribution`

---

## Task 3: weibull_dist distribution

**Files:**
- Create: `R/weibull_dist.R`
- Create: `tests/testthat/test-weibull_dist.R`

Constructor: weibull_dist(shape, scale), both positive scalars.
Classes: c("weibull_dist", "univariate_dist", "continuous_dist", "dist")
Mean: scale * gamma(1 + 1/shape), Var: scale^2 * (gamma(1+2/shape) - gamma(1+1/shape)^2)
Methods: full set + closed-form hazard: (shape/scale)*(t/scale)^(shape-1)
Backed by: stats::dweibull, pweibull, qweibull, rweibull
Support: interval (0, Inf) open at 0

Cross-validate: weibull_dist(1, 1/rate) matches exponential(rate).

Commit: `feat: add weibull_dist distribution`

---

## Task 4: Scalar multiplication, location shift, Gamma addition rules

**Files:**
- Modify: `R/edist.R` (add *.dist, modify +.dist and -.dist for numeric args)
- Modify: `R/algebra.R` (add simplification rules)
- Create: `tests/testthat/test-algebra-extended.R`

### *.dist operator
- numeric * dist: substitute scalar into expression, simplify
- dist * numeric: same (commutative)
- dist * dist: edist with no simplification

### +.dist / -.dist extended
- dist + numeric: location shift via edist + simplify
- numeric + dist: same

### Simplification rules (in algebra.R)

Single-variable (length(vars)==1):
- k * Normal(mu,v) -> Normal(k*mu, k^2*v)
- k * Gamma(a,r) -> Gamma(a, r/k) when k > 0
- k * Exponential(r) -> Gamma(1, r/k) when k > 0
- Normal(mu,v) + k -> Normal(mu+k, v)
- Normal(mu,v) - k -> Normal(mu-k, v)

Two-variable (length(vars)==2):
- Gamma(a1,r) + Gamma(a2,r) -> Gamma(a1+a2, r) when same rate
- Exp(r) + Exp(r) -> Gamma(2, r) when same rate
- Gamma(a,r) + Exp(r) -> Gamma(a+1, r) when same rate

Note: scalar extraction from expressions uses R's standard expression inspection (expr[[2]], expr[[3]]) — the existing pattern in simplify.edist already does this for operator detection.

Tests: c*normal, normal*c, c*gamma, c*exponential, negative scalar, dist*dist stays edist, normal+scalar, scalar+normal, normal-scalar, exp+scalar stays edist, gamma+gamma same rate, gamma+gamma different rate stays edist, exp+exp same rate, exp+exp different rate stays edist.

Commit: `feat: add scalar multiplication, location shift, and Gamma addition rules`

---

## Task 5: chi_squared distribution

**Files:**
- Create: `R/chi_squared.R`
- Create: `tests/testthat/test-chi_squared.R`
- Modify: `R/algebra.R` (ChiSq + ChiSq rule)

Constructor: chi_squared(df), df > 0.
Classes: c("chi_squared", "univariate_dist", "continuous_dist", "dist")
Mean: df, Var: 2*df
Methods: full set + hazard (f/S) + surv
Backed by: stats::dchisq, pchisq, qchisq, rchisq
Support: interval (0, Inf) open at 0

Rule: ChiSq(d1) + ChiSq(d2) -> ChiSq(d1+d2)

Commit: `feat: add chi_squared distribution with addition rule`

---

## Task 6: Power operator and Normal(0,1)^2 rule

**Files:**
- Modify: `R/edist.R` (add ^.dist)
- Modify: `R/algebra.R` (power simplification)
- Modify: `tests/testthat/test-algebra-extended.R`

### ^.dist
- x^y where x is dist and y is numeric scalar
- Substitutes exponent into expression, simplifies

### Rule
- Normal(0,1)^2 -> chi_squared(1) (single-variable, op=^, exponent=2, standard normal)

Chaining: normal(0,1)^2 + normal(0,1)^2 -> chi_squared(1) + chi_squared(1) -> chi_squared(2)

Tests: N(0,1)^2 simplifies, chaining works, non-standard normal stays edist, exponential^2 stays edist, power preserves sampling.

Commit: `feat: add power operator with Normal(0,1)^2 -> ChiSq rule`

---

## Task 7: uniform_dist distribution

**Files:**
- Create: `R/uniform_dist.R`
- Create: `tests/testthat/test-uniform_dist.R`

Constructor: uniform_dist(min=0, max=1), min < max.
Classes: c("uniform_dist", "univariate_dist", "continuous_dist", "dist")
Mean: (min+max)/2, Var: (max-min)^2/12
Backed by: stats::dunif, punif, qunif, runif
Support: interval [min, max] closed on both ends
No hazard/surv.

Commit: `feat: add uniform_dist distribution`

---

## Task 8: beta_dist distribution

**Files:**
- Create: `R/beta_dist.R`
- Create: `tests/testthat/test-beta_dist.R`

Constructor: beta_dist(shape1, shape2), both positive.
Classes: c("beta_dist", "univariate_dist", "continuous_dist", "dist")
Mean: shape1/(shape1+shape2), Var: shape1*shape2/((a+b)^2*(a+b+1))
Backed by: stats::dbeta, pbeta, qbeta, rbeta
Support: interval (0, 1) open
No hazard/surv.

Cross-validate: beta_dist(1, 1) density/cdf matches uniform_dist(0, 1).

Commit: `feat: add beta_dist distribution`

---

## Task 9: lognormal distribution

**Files:**
- Create: `R/lognormal.R`
- Create: `tests/testthat/test-lognormal.R`

Constructor: lognormal(meanlog=0, sdlog=1), sdlog > 0.
Classes: c("lognormal", "univariate_dist", "continuous_dist", "dist")
Mean: exp(meanlog + sdlog^2/2), Var: (exp(sdlog^2)-1)*exp(2*meanlog + sdlog^2)
Backed by: stats::dlnorm, plnorm, qlnorm, rlnorm
Support: interval (0, Inf) open at 0
hazard/surv: yes (reliability-relevant)

Commit: `feat: add lognormal distribution`

---

## Task 10: Math.dist group generic and exp/log rules

**Files:**
- Modify: `R/edist.R` (add Math.dist)
- Modify: `R/algebra.R` (exp/log rules)
- Modify: `tests/testthat/test-algebra-extended.R`

### Math.dist
S3 group generic dispatching exp(), log(), sqrt(), abs(), cos(), sin(), etc. through edist:

```r
Math.dist <- function(x, ...) {
  op <- .Generic
  expr <- substitute(OP(x), list(OP = as.name(op)))
  simplify(edist(expr, list(x = x)))
}
```

### Rules
- exp(Normal(mu, v)) -> lognormal(mu, sqrt(v))
- log(LogNormal(ml, sl)) -> normal(ml, sl^2)

Tests: exp(normal) simplifies, log(lognormal) simplifies, sqrt/abs/cos stay as edist, abs(normal) samples are non-negative, cos(uniform) mean near 0.

Commit: `feat: add Math.dist group generic with exp/log simplification`

---

## Task 11: poisson_dist and countable_set

**Files:**
- Create: `R/countable_set.R`
- Create: `R/poisson_dist.R`
- Modify: `R/algebra.R` (Poisson addition rule)
- Create: `tests/testthat/test-countable_set.R`
- Create: `tests/testthat/test-poisson_dist.R`

### countable_set
R6 class for countably infinite support (non-negative integers). Fields: lower_bound. Methods: has (checks integer >= lower), infimum, supremum (Inf), dim (1). S3 bridge methods: has.countable_set, infimum.countable_set, supremum.countable_set, dim.countable_set.

### poisson_dist
Constructor: poisson_dist(lambda), lambda > 0.
Classes: c("poisson_dist", "univariate_dist", "discrete_dist", "dist")
Mean: lambda, Var: lambda
Backed by: stats::dpois, ppois, qpois, rpois
Support: countable_set (non-negative integers)
No hazard/surv.

Exact expectation via truncated summation (k from 0 to qpois(1-1e-12, lambda)).

Rule: Poisson(l1) + Poisson(l2) -> Poisson(l1+l2)

Commit: `feat: add poisson_dist, countable_set, and Poisson addition rule`

---

## Task 12: Summary.dist group generic (min, max, sum, prod)

**Files:**
- Modify: `R/edist.R` (add Summary.dist)
- Create: `tests/testthat/test-summary-ops.R`

### Summary.dist
S3 group generic handling sum(), prod(), min(), max():
- sum: Reduce via +.dist (chains simplification)
- prod: Reduce via *.dist
- min: if all exponential, return exponential(sum of rates); otherwise build edist with pmin expression
- max: build edist with pmax expression
- Single element: return as-is

Note: use pmin/pmax (vectorized) in expressions, not min/max (which collapse to scalar).

Tests: sum of normals simplifies, min of exponentials simplifies, min of 3 exponentials, min of mixed stays edist, max stays edist, prod creates edist, single element returns self.

Commit: `feat: add Summary.dist (sum, prod, min, max) with min-of-exponentials rule`

---

## Task 13: mixture distribution

**Files:**
- Create: `R/mixture.R`
- Create: `tests/testthat/test-mixture.R`

Constructor: mixture(components, weights). Validates: non-empty list, weights match length, weights non-negative, weights sum to 1.
Classes: determined by components (mixture + univariate/multivariate + continuous/discrete + dist).

Key methods:
- mean: weighted sum of component means
- vcov: law of total variance (E[Var] + Var[E])
- density: weighted sum of component densities
- cdf: weighted sum of component CDFs
- sampler: categorical draw of component, then sample from it
- params: concatenated component params + weights
- sup: widest interval spanning all component supports

Commit: `feat: add mixture distribution`

---

## Task 14: Hardening — error messages

**Files:**
- Modify: `R/normal.R`, `R/exponential.R`, `R/mvn.R`, `R/empirical_dist.R`, `R/edist.R`
- Update corresponding test files

Replace all bare stopifnot() in constructors with informative stop() messages that include the parameter name and what was received.

Also add validation to edist() constructor: vars must be non-empty named list.

Update test expectations for error message patterns.

Commit: `refactor: replace stopifnot with informative error messages`

---

## Task 15: Hardening — format/print consistency

**Files:**
- Modify: `R/normal.R`, `R/exponential.R`, `R/mvn.R`, `R/empirical_dist.R`, `R/edist.R`

Add format.* methods to all existing types. Standardize print.* to delegate to format:
```r
print.TYPE <- function(x, ...) cat(format(x), "\n")
```

Special case: print.mvn keeps showing full mu/sigma, format.mvn shows dimension summary.

Commit: `refactor: add format methods and standardize print across all types`

---

## Task 16: Hardening — edge cases and numerical stability

**Files:**
- Modify: `R/empirical_dist.R` (informative error for empty conditional)
- Modify: `R/utils.R` (zero-variance CI guard)
- Update test files

Key fixes:
- conditional.empirical_dist: check for zero matches, give informative error
- expectation_data: guard against zero standard error when computing CIs
- Use drop=FALSE when subsetting single-column matrices

Commit: `fix: harden edge cases and numerical stability`

---

## Task 17: Version bump, NEWS, DESCRIPTION, final check

**Files:**
- Modify: `DESCRIPTION` (version 0.1.0 -> 0.2.0, update Description text and imports)
- Modify: `NEWS.md` (add 0.2.0 section)
- Modify: `.Rbuildignore` (confirm docs/ excluded)

Steps:
1. Update DESCRIPTION version and description text
2. Write NEWS.md 0.2.0 section
3. Run devtools::document()
4. Run devtools::check() — fix any issues
5. Run covr::package_coverage() — target 95%+
6. Commit

Commit: `chore: bump version to 0.2.0 and update NEWS`

---

## Execution Order Summary

| Task | Description | Dependencies | Est. Tests |
|------|-------------|-------------|------------|
| 1 | realize() + edist fallbacks | None | ~15 |
| 2 | gamma_dist | None | ~20 |
| 3 | weibull_dist | None | ~20 |
| 4 | Scalar mult + location shift + Gamma rules | Task 2 | ~20 |
| 5 | chi_squared | None | ~15 |
| 6 | Power operator + N(0,1)^2 rule | Task 5 | ~10 |
| 7 | uniform_dist | None | ~15 |
| 8 | beta_dist | Task 7 (cross-validation) | ~15 |
| 9 | lognormal | None | ~15 |
| 10 | Math.dist + exp/log rules | Task 9 | ~10 |
| 11 | poisson_dist + countable_set | None | ~20 |
| 12 | Summary.dist (min/max/sum/prod) | Tasks 2, 4 | ~15 |
| 13 | mixture | None | ~15 |
| 14 | Hardening: error messages | Tasks 1-13 | ~10 |
| 15 | Hardening: format/print | Tasks 1-13 | ~10 |
| 16 | Hardening: edge cases | Tasks 14-15 | ~10 |
| 17 | Version bump + NEWS + check | All | ~0 |

**Parallelizable groups:**
- Group A (independent): Tasks 1, 2, 3, 5, 7, 9, 11, 13
- Group B (depends on A): Tasks 4, 6, 8, 10, 12
- Group C (depends on all): Tasks 14, 15, 16, 17
