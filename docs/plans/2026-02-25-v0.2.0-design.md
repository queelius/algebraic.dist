# algebraic.dist v0.2.0 Design

**Date**: 2026-02-25
**Status**: Approved
**Goal**: Broaden distribution catalogue, deepen the algebra, harden the package before CRAN resubmission.
**Constraint**: No breaking backwards compatibility with v0.1.0.

## Architecture

Every new distribution follows the existing S3 pattern:

```r
constructor(params) -> S3 object with class vector
```

Each implements the full method set: `mean`, `vcov`, `params`, `nparams`, `dim`,
`print`, `format`, `sup`, `sampler`, `density`, `cdf`, `inv_cdf`, plus
`hazard`/`surv` for reliability-relevant types, and `is_<type>` predicate.

Naming convention uses suffixed names to avoid shadowing base R: `gamma_dist`,
`uniform_dist`, `beta_dist`, `poisson_dist`, `chi_squared`, `lognormal`,
`weibull_dist`.

Constructor validation uses informative `stop()` calls (not bare `stopifnot`):

```r
if (!is.numeric(shape) || length(shape) != 1 || shape <= 0)
  stop("'shape' must be a positive scalar, got: ", deparse(shape))
```

## Slice 1: Gamma, Weibull, Scaling, Realize

### New distributions

**gamma_dist(shape, rate)** — shape > 0, rate > 0
- Classes: `c("gamma_dist", "univariate_dist", "continuous_dist", "dist")`
- Mean: shape/rate, Var: shape/rate^2
- hazard/surv: computed from density/CDF
- Backed by `stats::dgamma`, `pgamma`, `qgamma`, `rgamma`

**weibull_dist(shape, scale)** — shape > 0, scale > 0
- Classes: `c("weibull_dist", "univariate_dist", "continuous_dist", "dist")`
- Mean: scale * gamma(1 + 1/shape)
- hazard: (shape/scale) * (t/scale)^(shape-1) — closed form
- Backed by `stats::dweibull`, `pweibull`, `qweibull`, `rweibull`

### Scalar multiplication operator

`*.dist(x, y)` — one argument numeric scalar, other a dist:
- Creates `edist(quote(c * x), list(x = d))` then simplifies.
- When both arguments are dist, creates `edist(quote(x * y), list(x, y))` (no simplification, realize fallback).

### Location shift

Extend `+.dist` and `-.dist` to handle numeric + dist and dist + numeric:
- `Normal(mu, var) + c` -> `Normal(mu + c, var)`
- Other types: edist with realize fallback.

### realize() generic

Materialize any dist to empirical_dist by sampling:

```r
realize(x, n = 10000)             # generic
realize.edist(x, n = 10000)       # sample and wrap
realize.dist(x, n = 10000)        # sample and wrap
realize.empirical_dist(x, n=NULL) # return as-is
```

### Auto-fallback edist methods

Methods that edist doesn't natively support delegate through realize:

```r
cdf.edist <- function(x, ...) cdf(realize(x))
density.edist <- function(x, ...) density(realize(x))
# etc.
```

### Simplification rules (Slice 1)

| Expression | Result | Condition |
|---|---|---|
| `c * Normal(mu, v)` | `Normal(c*mu, c^2*v)` | c is numeric scalar |
| `c * Gamma(a, r)` | `gamma_dist(a, r/c)` | c > 0 |
| `c * Exponential(r)` | `gamma_dist(1, r/c)` | c > 0 |
| `Normal(mu, v) + c` | `Normal(mu+c, v)` | c is numeric scalar |
| `c + Normal(mu, v)` | `Normal(mu+c, v)` | c is numeric scalar |
| `Exp(r) + Exp(r)` | `gamma_dist(2, r)` | Same rate |
| `Gamma(a1, r) + Gamma(a2, r)` | `gamma_dist(a1+a2, r)` | Same rate |

## Slice 2: Chi-squared, Power Operator

### New distribution

**chi_squared(df)** — df > 0
- Classes: `c("chi_squared", "univariate_dist", "continuous_dist", "dist")`
- Mean: df, Var: 2*df
- Relationship: Gamma(df/2, 1/2)
- Backed by `stats::dchisq`, `pchisq`, `qchisq`, `rchisq`

### Power operator

`^.dist(x, y)` — x is dist, y is numeric scalar:
- Creates `edist(quote(x^y), list(x = d))` then simplifies.

### Simplification rules (Slice 2)

| Expression | Result | Condition |
|---|---|---|
| `Normal(0,1) ^ 2` | `chi_squared(1)` | mu == 0, var == 1 |
| `ChiSq(d1) + ChiSq(d2)` | `chi_squared(d1 + d2)` | Always |

Pattern matching in `simplify.edist` extended to handle `length(vars) == 1` for
single-variable expressions (power, unary transforms).

## Slice 3: Uniform, Beta, Log-normal, Math Group Generic

### New distributions

**uniform_dist(min, max)** — min < max
- Classes: `c("uniform_dist", "univariate_dist", "continuous_dist", "dist")`
- Mean: (min+max)/2, Var: (max-min)^2/12
- Support: interval [min, max] closed
- Backed by `stats::dunif`, `punif`, `qunif`, `runif`

**beta_dist(shape1, shape2)** — shape1 > 0, shape2 > 0
- Classes: `c("beta_dist", "univariate_dist", "continuous_dist", "dist")`
- Mean: shape1/(shape1+shape2)
- Support: interval (0, 1) open
- Backed by `stats::dbeta`, `pbeta`, `qbeta`, `rbeta`
- No hazard/surv

**lognormal(meanlog, sdlog)** — sdlog > 0
- Classes: `c("lognormal", "univariate_dist", "continuous_dist", "dist")`
- Mean: exp(meanlog + sdlog^2/2)
- Support: interval (0, Inf) open
- Backed by `stats::dlnorm`, `plnorm`, `qlnorm`, `rlnorm`
- hazard/surv: yes (reliability-relevant)

### Math group generic

`Math.dist` handles `exp()`, `log()`, `sqrt()`, `abs()`, etc. via S3 group
generic dispatch:

```r
Math.dist <- function(x, ...) {
  op <- .Generic
  expr <- substitute(OP(x), list(OP = as.name(op)))
  simplify(edist(expr, list(x = x)))
}
```

Natural R syntax: `exp(normal(0, 1))` just works.

### Simplification rules (Slice 3)

| Expression | Result | Condition |
|---|---|---|
| `exp(Normal(mu, v))` | `lognormal(mu, sqrt(v))` | Always |
| `log(LogNormal(ml, sl))` | `normal(ml, sl^2)` | Always |

## Slice 4: Poisson, Countable Set

### New distribution

**poisson_dist(lambda)** — lambda > 0
- Classes: `c("poisson_dist", "univariate_dist", "discrete_dist", "dist")`
- Mean: lambda, Var: lambda
- Support: `countable_set` (new)
- Backed by `stats::dpois`, `ppois`, `qpois`, `rpois`
- No hazard/surv

### countable_set R6 class

New support class for countably infinite discrete sets:

```r
countable_set <- R6::R6Class("countable_set",
  public = list(
    initialize = function(lower = 0L, upper = Inf) { ... }
  )
)
# has(x): checks non-negative integer
# infimum(): returns lower bound
# supremum(): returns Inf
# dim(): returns 1
```

### Exact expectation

Poisson gets a dedicated expectation method using exact summation:

```r
expectation.poisson_dist <- function(x, g, ...) {
  k_max <- qpois(1 - 1e-10, lambda = x$lambda)
  k <- 0:k_max
  sum(g(k, ...) * dpois(k, lambda = x$lambda))
}
```

### Simplification rules (Slice 4)

| Expression | Result | Condition |
|---|---|---|
| `Poisson(l1) + Poisson(l2)` | `poisson_dist(l1 + l2)` | Always |

## Slice 5: min/max, Mixtures, Product

### Summary group generic

`Summary.dist` handles `min()`, `max()`, `sum()`, `prod()`:

```r
Summary.dist <- function(..., na.rm = FALSE) {
  op <- .Generic
  dists <- list(...)
  if (op == "sum") return(Reduce(`+.dist`, dists))
  if (op == "prod") return(Reduce(`*.dist`, dists))
  # min/max: build edist
  ...
}
```

Natural R syntax: `min(exp1, exp2)`, `sum(n1, n2, n3)`.

### Mixture distributions

`mixture(dists, weights)` — dedicated constructor, not an operator overload:
- `dists`: list of dist objects
- `weights`: numeric vector summing to 1
- Classes: determined by components (univariate/multivariate, continuous/discrete)
- Sampler: categorical draw of component, then sample from that component
- Density: weighted sum of component densities
- CDF: weighted sum of component CDFs
- Mean: weighted sum of component means
- Vcov: law of total variance

No simplification rules — mixtures are already canonical.

### Simplification rules (Slice 5)

| Expression | Result | Condition |
|---|---|---|
| `min(Exp(r1), ..., Exp(rk))` | `exponential(sum(rates))` | All exponential |

## Slice 6: Hardening

### Error messages

Replace all `stopifnot` with informative `stop()` in every constructor (existing
and new). Pattern:

```r
if (!is.numeric(rate) || length(rate) != 1 || rate <= 0)
  stop("'rate' must be a positive numeric scalar, got: ", deparse(rate))
```

### format/print consistency

Add `format` methods to all distribution types. Standardize `print` to delegate
to `format`:

```r
format.gamma_dist <- function(x, ...) {
  sprintf("Gamma distribution (shape = %g, rate = %g)", x$shape, x$rate)
}
print.gamma_dist <- function(x, ...) {
  cat(format(x), "\n")
}
```

Retrofit existing types: `normal`, `mvn`, `exponential`, `empirical_dist`, `edist`.

### Edge cases

| Edge case | Behavior |
|---|---|
| `normal(0, 0)` degenerate | Sampler returns constant, density Inf at mu, CDF step |
| `empirical_dist` 1 observation | Works, vcov returns NA/0 |
| `conditional()` filtering to 0 rows | Informative error |
| `realize()` with n = 0 | Error with message |
| `mixture()` mismatched lengths | Error with message |
| `min()`/`max()` single dist | Returns unchanged |

### Numerical stability

| Issue | Fix |
|---|---|
| MC estimation all-zero variance | Return 0 variance in CI |
| `density.empirical_dist` large n | Document O(n) limitation |
| `realize()` default n | 10000 (consistent with existing defaults) |

## Version

- DESCRIPTION: 0.1.0 -> 0.2.0
- NEWS.md: document all new distributions, operators, and fixes
- .Rbuildignore: add `^docs$`

## All simplification rules (consolidated)

| Expression | Result | Condition | Slice |
|---|---|---|---|
| `Normal + Normal` | `Normal(mu1+mu2, v1+v2)` | Always | Existing |
| `Normal - Normal` | `Normal(mu1-mu2, v1+v2)` | Always | Existing |
| `-Normal` | `Normal(-mu, v)` | Always | Existing |
| `c * Normal(mu, v)` | `Normal(c*mu, c^2*v)` | Scalar c | 1 |
| `c * Gamma(a, r)` | `gamma_dist(a, r/c)` | c > 0 | 1 |
| `c * Exponential(r)` | `gamma_dist(1, r/c)` | c > 0 | 1 |
| `Normal + c` | `Normal(mu+c, v)` | Scalar c | 1 |
| `Exp(r) + Exp(r)` | `gamma_dist(2, r)` | Same rate | 1 |
| `Gamma(a1,r) + Gamma(a2,r)` | `gamma_dist(a1+a2, r)` | Same rate | 1 |
| `Normal(0,1) ^ 2` | `chi_squared(1)` | Standard normal | 2 |
| `ChiSq(d1) + ChiSq(d2)` | `chi_squared(d1+d2)` | Always | 2 |
| `exp(Normal(mu, v))` | `lognormal(mu, sqrt(v))` | Always | 3 |
| `log(LogNormal(ml, sl))` | `normal(ml, sl^2)` | Always | 3 |
| `Poisson(l1) + Poisson(l2)` | `poisson_dist(l1+l2)` | Always | 4 |
| `min(Exp(r1),...,Exp(rk))` | `exponential(sum(r))` | All exponential | 5 |
